import os
import yaml
import shutil
from tqdm import tqdm
from sklearn.model_selection import KFold

import argument_dataset

ALL_PAR_NAME = ["origin", "classification", "extend"]
ALL_ACTIONS = ["stand", "squat", "one-foot-stand", 
               "open-arms", "arms-skimbo"]
KP_CLASS = {0 : "Nose", 1 : "Left Eye", 2 : "Right Eye", 3 : "Left Ear", 4 : "Right Ear", 
            5 : "Left Shoulder", 6 : "Right Shoulder", 7 : "Left Elbow", 8 : "Right Elbow", 
            9 : "Left Wrist", 10 : "Right Wrist", 11 : "Left Hip", 12 : "Right Hip", 
            13 : "Left Knee", 14 : "Right Knee", 15 : "Left Ankle", 16 : "Right Ankle"}

os.chdir(os.path.dirname(os.path.abspath(__file__)) + "/..")
video_root = os.path.join(os.getcwd(), "assets", "videos")
pic_with_keypoints_root = os.path.join(
    os.getcwd(), "data", "pic_keypoints_label"
)

def annotate_action():
    '''
    To annotate_action, just classify the action of the pics and
    yaml file generated by video, and copy corresponding pics to the
    diretory in ./data/pic_keypoints_label/classification
    '''
    action_root_path = os.path.join(pic_with_keypoints_root, "classification")
    output_path = os.path.join(action_root_path, "database")
    for action_path in enumerate(os.listdir(action_root_path)):
        if os.path.dirname(action_path) != action_root_path and os.path.isfile(action_path):
            with open(action_path, 'r') as f:
                data = yaml.safe_load(f)
            kps = [{
                "x": x,
                "y": y,
                "vx": vx,
                "vy": vy
            }]
            label_data = {
                "name": os.path.basename(action_path).split(".")[0],
                "action": os.path.dirname(action_path),

            }
            file_path = os.path.join(output_path, action_path.split(".")[0] + ".yaml")
            with open(file_path, 'r') as f:
                yaml.dump()



def iterate_files(directory):
    for root, dirs, files in os.walk(directory):
        for file in files:
            yield os.path.join(root, file)

def check_dirs(dirs):
    for dir in dirs:
        if not os.path.exists(dir):
            os.makedirs(dir)

def create_keypoint_label_data_dir(video_path):
    '''
    create directory for every video
    @param video_path: video path
    '''
    video_name = os.path.basename(video_path)
    root_dir = os.path.join(pic_with_keypoints_root, video_name.split(".")[0])
    check_dirs([pic_with_keypoints_root, root_dir])

    for name in ALL_PAR_NAME:
        parent_dir = os.path.join(root_dir, name)
        check_dirs([parent_dir])
    for action in ALL_ACTIONS:
        action_dir = os.path.join(root_dir, ALL_PAR_NAME[1], action)
        check_dirs([action_dir])

def get_origin_pic_dir(video_path):
    return os.path.join(
        pic_with_keypoints_root,
        os.path.basename(video_path).split(".")[0],
        "origin"
    )

def get_extend_pic_dir(video_path):
     return os.path.join(
        pic_with_keypoints_root,
        os.path.basename(video_path).split(".")[0],
        "extend"
    )

def get_action_dir(video_path, action):
    '''
    get the target action directory of a video
    @param video_path: the full path of the video
    @param action: the action of the person
    '''
    return os.path.join(
        pic_with_keypoints_root,
        os.path.basename(video_path).split(".")[0],
        f"classification",
        action
    )

def get_origin_data_path(video_path):
    '''
    get the origin data path of a video (after yolo detect)
    @param video_path: the full path of the video
    '''
    return os.path.join(
        pic_with_keypoints_root,
        os.path.basename(video_path).split(".")[0]
    )

def format2yolo(pic_kp_lab_path):
    '''
    transform communicate config to YOLO training format
    @param pic_kp_lab_path: transform kp_lab format to yolo eg: pic_keypoints_lable/video1
    '''

    formated_path = os.path.join(pic_kp_lab_path, 'formated')
    formated_path_label = os.path.join(formated_path, 'formated_label')
    formated_path_img = os.path.join(formated_path, 'formated_img')

    check_dirs([formated_path, formated_path_label, formated_path_img])
    
    # process files
    total_size = len(os.listdir(os.path.join(pic_kp_lab_path, "origin")))
    for file_iter in tqdm(enumerate(os.listdir(os.path.join(pic_kp_lab_path, "origin"))), total=total_size,
                          desc="format dataset to yolo format"):
        file_iter = file_iter[1]
        if file_iter.split(".")[1] == "yaml":
            with open(os.path.join(pic_kp_lab_path, "origin", file_iter), 'r') as f:
                data = yaml.safe_load(f)
            
            img_width = data["pic_size"]["w"]
            img_height = data["pic_size"]["h"]
            output = ""
            for person_idx, person_points in enumerate(data["keypoints"]):
                xb = data["boxes"][person_idx]["x"]
                yb = data["boxes"][person_idx]["y"]
                wb = data["boxes"][person_idx]["w"]
                hb = data["boxes"][person_idx]["h"]
                output += f"{0} {xb / img_width} {yb / img_height} {wb / img_width} {hb / img_height}"
                for point in person_points["points"]:
                    output += f" {point['x'] / img_width} {point['y'] / img_height}"
                output += "\n"
            txt_file = os.path.join(formated_path_label, 
                                    file_iter.split(".")[0] + ".txt")
            with open(txt_file, 'w') as f:
                f.write(output)
            
            # add extend yaml
            for ext in argument_dataset.extend_type:
                shutil.copy(txt_file, os.path.join(formated_path_label, 
                                         file_iter.split(".")[0] + f"_{ext}.txt"))
            
        elif file_iter.split(".")[1] == "jpg":
            shutil.copy(os.path.join(pic_kp_lab_path, "origin", file_iter), 
                        os.path.join(formated_path_img, file_iter))
            # add extend jpg
            name = file_iter.split(".")[0]
            for ext in argument_dataset.extend_type:
                shutil.copy(os.path.join(pic_kp_lab_path, "extend", f"{name}_{ext}.jpg"), 
                            os.path.join(formated_path_img, f"{name}_{ext}.jpg"))

def split_yolo_train_val(pic_kp_lab_path, K=5):
    '''
    split yolo dataset to train and val
    @param pic_kp_lab_path: the path of the formated dataset
    @param train_ratio: the ratio of train dataset
    @return fold_dir: iterator of the directory of the fold
    '''
    formated_path = os.path.join(pic_kp_lab_path, 'formated')
    formated_img_path = os.path.join(formated_path, 'formated_img')
    formated_label_path = os.path.join(formated_path, 'formated_label')
    if not os.path.exists(formated_path) or not os.path.exists(formated_img_path) or not os.path.exists(formated_label_path):
        print("Please format the dataset first!")
        return
    dataset_path = os.path.join(pic_kp_lab_path, 'database')
    check_dirs([dataset_path])

    data_list = []
    for idx, (img, label) in enumerate(zip(os.listdir(formated_img_path), os.listdir(formated_label_path))):
        img_path = os.path.join(formated_img_path, img) 
        label_path = os.path.join(formated_label_path, label)
        if os.path.exists(img_path):
            data_list.append((img_path, label_path))

    kf = KFold(n_splits=K, shuffle=True, random_state=22)
    k_folds = []
    with tqdm(total=K, desc="Splitting folds", position=1, leave=True) as pbar_outer:
        for fold, (train_idx, val_idx) in enumerate(kf.split(data_list)):    
            fold_dir = os.path.join(dataset_path, f"fold_{fold}")
            os.makedirs(os.path.join(fold_dir, "images", "train"), exist_ok=True)
            os.makedirs(os.path.join(fold_dir, "images", "val"), exist_ok=True)
            os.makedirs(os.path.join(fold_dir, "labels", "train"), exist_ok=True)
            os.makedirs(os.path.join(fold_dir, "labels", "val"), exist_ok=True)
            
            # copy data to train and val
            with tqdm(total=len(train_idx),desc=f"Copying train data for fold {fold}", position=2, leave=False) as pbar:
                for idx in train_idx:
                    img_path, label_path = data_list[idx]
                    shutil.copy(img_path, os.path.join(fold_dir, "images", "train"))
                    shutil.copy(label_path, os.path.join(fold_dir, "labels", "train"))
                    pbar.update(1)
            with tqdm(total=len(val_idx),desc=f"Copying val data for fold {fold}", position=2, leave=False) as pbar:
                for idx in val_idx:
                    img_path, label_path = data_list[idx]
                    shutil.copy(img_path, os.path.join(fold_dir, "images", "val"))
                    shutil.copy(label_path, os.path.join(fold_dir, "labels", "val"))
                    pbar.update(1)
            
            # create dataset.yaml
            yaml_content = f"""
path: {os.path.abspath(fold_dir)}
train: images/train
val: images/val

kpt_shape: [17, 2]
flip_idx: [0, 2, 1, 4, 3, 6, 5, 8, 7, 10, 9, 12, 11, 14, 13, 16, 15]

names:
    0: person
            """
            with open(os.path.join(fold_dir, "coco8-pose.yaml"), "w") as f:
                f.write(yaml_content)

            k_folds.append(fold_dir)
            pbar_outer.update(1)

    return k_folds

def get_KFold(database_path):
    with os.scandir(database_path) as entries:
        kfold = [os.path.join(database_path, entry.name) for entry in entries if entry.is_dir()]

    return kfold


    
def test():
  for file in iterate_files(video_root):
      if file.endswith(".mp4"):
          video_name = os.path.basename(file).split(".")[0]
          create_keypoint_label_data_dir(video_name)

if __name__ == "__main__":
    format2yolo(f"/home/tdt/Documents/project/HumanPoseClassify/data/pic_keypoints_label/video1")